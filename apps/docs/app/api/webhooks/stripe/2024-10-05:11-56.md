// File: accountHandler.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin'; // Supabase client
import { Database } from '@/types/supabase'; // Import the generated Database type

// Define TypeScript type aliases using Supabase's Database type
type AccountRecord = Database['public']['Tables']['accounts']['Row'];

// Manage user accounts based on user ID
export async function manageAccount(userId: string) {
  console.log(`>>> Managing account for user ID: ${userId}`);

  try {
    // Check if the account already exists
    const { data: account, error: accountError } = await supabaseAdmin
      .from('accounts')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (accountError) {
      // Handle the case where no account is found or another error occurs
      if (accountError.code === 'PGRST116') {
        console.warn(`No account found for user ID ${userId}: ${accountError.message}`);
      } else {
        console.error(`Error fetching account for user ID ${userId}: ${accountError.message}`);
      }
      // Proceed to create a new account since one doesn't exist
    } else if (account) {
      console.log(`Account already exists for user ID: ${userId}`);
      return; // Account exists, no action needed
    }

    // If no account exists, create a new account
    const newAccountData: Omit<AccountRecord, 'id'> = { // Exclude 'id' from the new account data
      account_number: generateUniqueAccountNumber(), // Call your unique account number generation function
      user_id: userId, // Reference the user ID
      status: 'active', // Default status
      max_devices: '5', // Default max devices
      cryptotoken: null, // Default value for cryptotoken
      can_add_ports: 'false', // Default value for can_add_ports
      can_add_devices: 'true', // Default value for can_add_devices
      max_ports: '0', // Default max ports
      expiry: '', // Default expiry
      apple_receipt: null, // Default value for apple_receipt
      apple_api_response: null, // Default value for apple_api_response
      created_at: new Date().toISOString(), // Set to current time
      marked_inactive_by_user: null, // Default value for marked_inactive_by_user
    };

    const { data: createdAccount, error: createError } = await supabaseAdmin
      .from('accounts')
      .insert([newAccountData]);

    if (createError) {
      console.error(`Failed to create account for user ID ${userId}: ${createError.message}`);
    } else {
      console.log(`Successfully created new account for user ID: ${userId}`, createdAccount);
    }
  } catch (error) {
    console.error('Error managing account:', error);
  }
}

// Function to generate a unique account number (adjust as necessary)
function generateUniqueAccountNumber(): string {
  return Math.floor(Math.random() * 10000000000000000).toString(); // Generate a unique number
}// File: handlers/priceSyncHandler.ts

import { stripe } from '@/utils/stripeClient';
import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';
import { v4 as uuidv4 } from 'uuid';

/**
 * Synchronizes Stripe products and their associated prices with Supabase.
 */
export async function syncStripeProductsAndPrices() {
  try {
    console.log('>>> Starting synchronization of Stripe products and prices.');

    // Fetch all active products from Stripe
    const products = await stripe.products.list({
      active: true,
      limit: 100, // Adjust as needed
    });

    for (const product of products.data) {
      // Upsert product into Supabase
      const supabaseProduct: Database['public']['Tables']['products']['Insert'] = {
        id: product.id,
        active: product.active,
        description: product.description || null,
        EAN: product.metadata.EAN || null, // Assuming EAN is stored in metadata
        image: product.images && product.images.length > 0 ? product.images[0] : null,
        ltr_order: product.metadata.ltr_order ? parseInt(product.metadata.ltr_order, 10) : null,
        metadata: product.metadata || {},
        name: product.name || null,
      };

      const { data: upsertedProduct, error: productError } = await supabaseAdmin
        .from('products')
        .upsert(supabaseProduct, { onConflict: 'id' });

      if (productError) {
        console.error(`Failed to upsert product ${product.id}:`, productError.message);
        continue; // Skip to the next product
      }

      console.log(`Product ${product.id} synchronized successfully.`);

      // Fetch prices for the current product
      const prices = await stripe.prices.list({
        product: product.id,
        active: true,
        limit: 100, // Adjust as needed
      });

      for (const price of prices.data) {
        const supabasePrice: Database['public']['Tables']['prices']['Insert'] = {
          id: price.id,
          product_id: product.id,
          active: price.active,
          unit_amount: price.unit_amount || null,
          currency: price.currency || null,
          type: price.type as Database['public']['Enums']['pricing_type'],
          interval: price.recurring?.interval || null,
          interval_count: price.recurring?.interval_count || null,
          trial_period_days: price.recurring?.trial_period_days || null,
          metadata: price.metadata || {},
        };

        const { data: upsertedPrice, error: priceError } = await supabaseAdmin
          .from('prices')
          .upsert(supabasePrice, { onConflict: 'id' });

        if (priceError) {
          console.error(`Failed to upsert price ${price.id}:`, priceError.message);
          continue; // Skip to the next price
        }

        console.log(`Price ${price.id} synchronized successfully.`);
      }
    }

    console.log('>>> Completed synchronization of Stripe products and prices.');
  } catch (error) {
    console.error('Error during synchronization of Stripe products and prices:', error);
  }
}// File: handlers/subscriptionHandler.ts

import { stripe } from '@/utils/stripeClient';
import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';

export type SubscriptionRecord = {
  id: string;
  user_id: string;
  status: string;
  metadata?: any;
  price_id?: string | null;
  quantity?: number | null;
  cancel_at_period_end?: boolean | null;
  created: string;
  current_period_start?: string;
  current_period_end?: string | null;
  ended_at?: string | null;
  cancel_at?: string | null;
  canceled_at?: string | null;
  trial_start?: string | null;
  trial_end?: string | null;
  stripe_subscription_id?: string | null;
  amount?: number | null;
  currency?: string | null;
  description?: string | null;
};

/**
 * Ensures that a specific price exists in Supabase. If not, fetches it from Stripe and inserts it.
 * @param priceId - The Stripe price ID.
 * @returns A boolean indicating whether the price exists after the function executes.
 */
async function ensurePriceExists(priceId: string): Promise<boolean> {
  const { data, error } = await supabaseAdmin
    .from('prices')
    .select('id')
    .eq('id', priceId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') { // Price not found
      console.log(`Price ID ${priceId} not found in Supabase. Fetching from Stripe...`);
      try {
        const price = await stripe.prices.retrieve(priceId);
        const supabasePrice: Database['public']['Tables']['prices']['Insert'] = {
          id: price.id,
          active: price.active,
          currency: price.currency,
          interval: price.recurring?.interval || null,
          interval_count: price.recurring?.interval_count || null,
          metadata: price.metadata || {},
          product_id: price.product as string,
          trial_period_days: price.recurring?.trial_period_days || null,
          type: price.type as Database['public']['Enums']['pricing_type'],
          unit_amount: price.unit_amount || null,
        };

        const { data: insertedData, error: insertError } = await supabaseAdmin
          .from('prices')
          .insert([supabasePrice]);

        if (insertError) {
          console.error(`Failed to insert price ${priceId} into Supabase:`, insertError.message);
          return false;
        }

        console.log(`Price ${priceId} inserted into Supabase successfully.`);
        return true;
      } catch (stripeError) {
        console.error(`Error fetching price ${priceId} from Stripe:`, stripeError);
        return false;
      }
    } else {
      console.error(`Error fetching price ${priceId} from Supabase:`, error.message);
      return false;
    }
  }

  // Price exists
  return true;
}

/**
 * Provisions subscription information in Supabase.
 * @param session - The Stripe Checkout session object.
 * @param userId - The ID of the user in your system.
 */
export async function provisionSubscription(session: any, userId: string, subscriptionId: string | null)  {
  console.log(`>>> Provisioning subscription for session ID: ${session.id}`);

  const amountTotal = session.amount_total;
  const subscriptionValue = session.subscription;

  try {
    // If amount is greater than 0 and there's no subscription, it's a one-time payment (OTP)
    if (amountTotal > 0 && !subscriptionValue) {
      console.log(`>>> Detected one-time payment (OTP). Amount Total: ${amountTotal}`);
      await createOneTimePaymentSubscription(session, userId);
    } else if (subscriptionValue) {
      // If there's a subscription value, fetch the subscription details from Stripe
      const subscription = await stripe.subscriptions.retrieve(subscriptionValue);
      console.log(`>>> Retrieved subscription from Stripe:`, subscription);

      const priceId = subscription.items.data[0]?.price.id || null;

      if (priceId) {
        // Ensure that the price exists in Supabase, if not, insert it
        const priceExists = await ensurePriceExists(priceId);
        if (!priceExists) {
          throw new Error(`Price ID ${priceId} does not exist in Supabase after synchronization.`);
        }
      }

      // Prepare the subscription data to be inserted into Supabase
      const subscriptionData: SubscriptionRecord = {
        id: subscriptionValue, // Use the subscription value as the ID
        user_id: userId,
        status: subscription.status as any,
        metadata: subscription.metadata || null,
        price_id: subscription.items.data[0]?.price.id || null,
        quantity: subscription.items.data[0]?.quantity || 1,
        cancel_at_period_end: subscription.cancel_at_period_end || false,
        created: new Date(subscription.created * 1000).toISOString(),
        current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
        current_period_end: subscription.current_period_end
          ? new Date(subscription.current_period_end * 1000).toISOString()
          : null,
        ended_at: subscription.ended_at ? new Date(subscription.ended_at * 1000).toISOString() : null,
        cancel_at: subscription.cancel_at ? new Date(subscription.cancel_at * 1000).toISOString() : null,
        canceled_at: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,
        trial_start: subscription.trial_start ? new Date(subscription.trial_start * 1000).toISOString() : null,
        trial_end: subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,
        stripe_subscription_id: subscription.id,
        amount: amountTotal || null,
        currency: session.currency || null,
        description: null,
      };

      console.log(`>>> Inserting subscription data into Supabase:`, subscriptionData);
      const { data, error } = await supabaseAdmin
        .from('subscriptions')
        .insert([subscriptionData]);

      if (error) {
        console.error(`Failed to insert subscription data: ${error.message}`);
      } else {
        console.log(`Successfully inserted subscription ${subscription.id}.`);
      }
    } else {
      console.warn(`No valid subscription ID found, skipping provisioning.`);
    }
  } catch (error) {
    console.error('Error provisioning subscription:', error);
  }
}

/**
 * Creates a one-time payment subscription in Supabase.
 * @param session - The Stripe Checkout session object.
 * @param userId - The ID of the user in your system.
 */
async function createOneTimePaymentSubscription(session: any, userId: string) {
  try {
    // Prepare the data for the one-time payment subscription to be inserted into Supabase
    const otpSubscriptionData: SubscriptionRecord = {
      id: session.subscription || `otp_${Date.now()}`, // Use subscription value if available, otherwise generate a temporary ID
      user_id: userId, // Use the retrieved user ID
      status: 'one_time_purchase', // Status for one-time purchases
      metadata: session.metadata || null,
      price_id: null, // No price ID for OTP
      quantity: 1, // Quantity for one-time purchase
      cancel_at_period_end: false,
      created: new Date(session.created * 1000).toISOString(),
      current_period_start: new Date(session.created * 1000).toISOString(),
      current_period_end: null, // No specific end for OTP
      ended_at: null,
      cancel_at: null,
      canceled_at: null,
      trial_start: null,
      trial_end: null,
      stripe_subscription_id: null, // No Stripe subscription ID for OTP
      amount: session.amount_total || 0, // Use the amount total from the session
      currency: session.currency || null, // Set currency based on session data
      description: null, // Optional description field
    };

    console.log(`>>> Inserting one-time payment subscription data into Supabase:`, otpSubscriptionData);
    const { data, error } = await supabaseAdmin
      .from('subscriptions')
      .insert([otpSubscriptionData]);

    if (error) {
      console.error(`Failed to insert one-time payment subscription: ${error.message}`);
    } else {
      console.log(`Successfully inserted one-time payment subscription.`);
    }
  } catch (error) {
    console.error('Error creating one-time payment subscription:', error);
  }
}
// File: handlers/voucherHandler.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';

/**
 * Defines the structure of a Voucher.
 */
type VoucherRecord = Database['public']['Tables']['vouchers']['Row'];

/**
 * Generates a unique 16-digit integer voucher code.
 * @returns A unique 16-digit voucher code string.
 */
function generateVoucherCode(): string {
  // Generate a random 16-digit integer as a string
  let code = '';
  for (let i = 0; i < 16; i++) {
    code += Math.floor(Math.random() * 10).toString();
  }
  return code;
}

/**
 * Generates a unique voucher code ensuring no duplication in the database.
 * @returns A unique 16-digit voucher code string.
 */
async function generateUniqueVoucherCode(): Promise<string> {
  let isUnique = false;
  let code = '';

  while (!isUnique) {
    code = generateVoucherCode();
    // Check if the code already exists
    const { data, error } = await supabaseAdmin
      .from('vouchers')
      .select('id')
      .eq('code', code)
      .single();

    if (error && error.code === 'PGRST116') {
      // Code is unique
      isUnique = true;
    } else {
      // Code already exists or another error occurred
      console.warn(`Voucher code ${code} already exists or an error occurred. Generating a new one.`);
    }
  }

  return code;
}

/**
 * Creates and assigns a voucher to the user's associated account.
 * @param userId - The ID of the user.
 * @param durationMonths - The duration in months for the voucher.
 * @param subscriptionId - The Stripe subscription ID associated with the purchase (optional).
 */
export async function createAndAssignVoucher(
  userId: string,
  durationMonths: number,
  subscriptionId: string | null = null
) {
  try {
    console.log(`>>> Creating voucher for user ID: ${userId} with duration: ${durationMonths} months`);

    // Generate a unique 16-digit voucher code
    const voucherCode = await generateUniqueVoucherCode();

    // Retrieve the user's associated account with account_number
    const { data: account, error: accountError } = await supabaseAdmin
      .from('accounts')
      .select('account_number, expiry')
      .eq('user_id', userId)
      .single();

    if (accountError) {
      console.error(`Error fetching account for user ID ${userId}:`, accountError.message);
      throw new Error('Failed to retrieve user account.');
    }

    if (!account) {
      console.error(`No account found for user ID ${userId}.`);
      throw new Error('User account does not exist.');
    }

    // Calculate the new expiry date by adding durationMonths
    const currentExpiry = new Date(account.expiry);
    const newExpiry = new Date(currentExpiry);
    newExpiry.setMonth(newExpiry.getMonth() + durationMonths);

    // Prepare the new voucher data
    const newVoucher: Omit<VoucherRecord, 'id' | 'created_at' | 'updated_at'> = {
      associated_account: account.account_number, // Correctly reference account_number
      channel_id: null, // Set accordingly if needed
      code: voucherCode,
      duration_months: durationMonths,
      is_used: true, // Mark as used immediately
      payment_intent_id: null, // Set accordingly if needed
      status: 'active', // Adjust based on your business logic
      subscription_id: subscriptionId, // Set based on the parameter
      updated_by: null,
      used_at: new Date().toISOString(),
      // Add other fields if necessary
    };

    // Insert the new voucher
    const { data: insertedVoucher, error: insertError } = await supabaseAdmin
      .from('vouchers')
      .insert([newVoucher]);

    if (insertError) {
      console.error('Error inserting voucher:', insertError.message);
      throw new Error('Failed to insert voucher.');
    }

    console.log(`>>> Successfully created and assigned voucher ${voucherCode} to account ${account.account_number}.`);

    // Update the account's expiry date
    const { error: updateError } = await supabaseAdmin
      .from('accounts')
      .update({ expiry: newExpiry.toISOString() })
      .eq('account_number', account.account_number); // Ensure to match account_number

    if (updateError) {
      console.error(`Error updating expiry for account number ${account.account_number}:`, updateError.message);
      throw new Error('Failed to update account expiry.');
    }

    console.log(`>>> Updated account ${account.account_number} expiry to ${newExpiry.toISOString()}.`);
  } catch (error) {
    console.error('>>> Error in createAndAssignVoucher:', error);
    throw error; // Re-throw the error after logging
  }
}// File: handlers/webhookHandler.ts

import { stripe } from '@/utils/stripeClient'; // Centralized Stripe instance
import { supabaseAdmin, getUserByEmail, createUser } from '@/utils/supabaseAdmin'; 
import { v4 as uuidv4 } from 'uuid';
import { Database } from '@/types/supabase'; // Import the generated Database type
import { provisionSubscription } from './subscriptionHandler'; // Import the provisionSubscription function
import { manageAccount } from './accountHandler'; // Import manageAccount function
import { sendReceiptEmail } from '@/app/api/webhooks/stripe/utils/emailUtils'; // Import the new email function

// Define TypeScript type aliases using Supabase's Database type
type CustomerRecord = Database['public']['Tables']['customers']['Row'];

// Handle 'checkout.session.completed' event
async function handleCheckoutCompleted(session) {
  // Log the raw session data received from Stripe for debugging
  console.log('>>> Raw session data received from Stripe:', JSON.stringify(session, null, 2));

  const customerEmail = session.customer_email ?? session.customer_details?.email ?? null;
  const fullName = session.customer_details?.name ?? null; 
  const profilePicUrl = session.customer_details?.image ?? null; // Assuming image is the field for profile picture

  console.log(`>>> Processing checkout.session.completed for email: ${customerEmail}`);

  if (!customerEmail) {
    console.warn('No customer email found in checkout.session.completed event.');
    return; // Exit early since email is essential
  }

  try {
    // Check if the user already exists
    const existingUser = await getUserByEmail(customerEmail);

    let userId: string | undefined; // Initialize userId

    if (existingUser) {
      console.log(`User already exists in auth.users: ${existingUser.id}`);
      userId = existingUser.id; // Store userId for later use
      // Update user information if needed, including profile picture
      await syncPublicUser(existingUser.id, customerEmail, fullName, profilePicUrl);
    } else {
      // If user does not exist, provision the new user
      const newPassword = uuidv4(); // Generate a new UUID for the password
      console.log(`Creating new user with email: ${customerEmail}`);
      const newUser = await createUser(customerEmail, newPassword);

      if (newUser) {
        console.log(`New user created: ${newUser.id}`);
        userId = newUser.id; // Store userId for later use
        // Sync the new user profile
        await syncPublicUser(newUser.id, customerEmail, fullName, profilePicUrl);
      } else {
        console.error('Failed to create a new user.');
        return; // Exit if user creation fails
      }
    }

    // Manage account for the user
    await manageAccount(userId); // Ensure the account is created or verified

    // Now provision the subscription based on the session
    await provisionSubscription(session, userId); // Pass both session and userId

  } catch (error) {
    console.error('Error processing checkout.session.completed:', error);
  }
}

// Handle other (unhandled) events
async function handleUnhandledEvent(event) {
  console.warn(`Unhandled event type: ${event.type}`);
}

// Sync user data to public.users table
async function syncPublicUser(userId: string, email: string | null, fullName: string | null, profilePicUrl: string | null) {
  if (!email) {
    console.warn(`Cannot sync public user without email for user ID: ${userId}`);
    return;
  }

  try {
    console.log(`>>> Upserting user profile in 'users' table for user ID: ${userId}`);
    const { data, error } = await supabaseAdmin
      .from('users') // Ensure this matches your Supabase table
      .upsert(
        { id: userId, email: email, full_name: fullName, avatar_url: profilePicUrl }, // Include profilePicUrl
        { onConflict: 'id' } // Ensure no duplicate entries
      );

    if (error) {
      console.error(`Failed to sync user profile for user ID ${userId}: ${error.message}`);
    } else {
      console.log(`User profile synced successfully for user ID: ${userId}.`);
    }
  } catch (error) {
    console.error(`Error in syncPublicUser for user ID ${userId}:`, error);
  }
}

// Handle 'charge.succeeded' event
async function handleChargeSucceeded(charge) {
  console.log('>>> Processing charge.succeeded event.');

  const receiptUrl = charge.receipt_url;
  const customerEmail = charge.receipt_email || charge.billing_details?.email;

  if (!customerEmail) {
    console.warn('No customer email found in charge.succeeded event.');
    return;
  }

  if (!receiptUrl) {
    console.warn('No receipt URL found in charge.succeeded event.');
    return;
  }

  try {
    // Send the receipt email
    await sendReceiptEmail(customerEmail, receiptUrl);
    console.log(`>>> Receipt email sent to ${customerEmail}`);
  } catch (error) {
    console.error('Error sending receipt email:', error);
  }
}

// Export the event handler function
export async function handleWebhookEvent(event) {
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object);
      break;
    case 'charge.succeeded':
      await handleChargeSucceeded(event.data.object);
      break;
    // Add additional cases for other events as needed
    default:
      await handleUnhandledEvent(event);
      break;
  }
}// File: apps/api/webhooks/stripe/utils/emailUtils.ts

import nodemailer from 'nodemailer';

// Initialize Nodemailer transporter with OAuth2 for enhanced security
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    type: 'OAuth2',
    user: process.env.GMAIL_USER,
    clientId: process.env.GMAIL_CLIENT_ID,
    clientSecret: process.env.GMAIL_CLIENT_SECRET,
    refreshToken: process.env.GMAIL_REFRESH_TOKEN,
  },
});

/**
 * Send a general email notification to the customer.
 * @param recipientEmail - The customer's email address.
 * @param sessionId - The Stripe Checkout session ID.
 */
export async function sendEmailNotification(recipientEmail: string, sessionId: string) {
  const mailOptions = {
    from: process.env.GMAIL_USER,
    to: recipientEmail,
    subject: 'Payment Confirmation',
    text: `Thank you for your purchase! Your session ID is: ${sessionId}.`,
    html: `<p>Thank you for your purchase!</p><p>Your session ID is: <strong>${sessionId}</strong>.</p>`,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent successfully:', info.response);
  } catch (error) {
    console.error('Error sending email:', error);
    throw new Error('Failed to send email.');
  }
}

/**
 * Send a receipt email to the customer with the receipt link.
 * @param recipientEmail - The customer's email address.
 * @param receiptUrl - The URL to the receipt.
 */
export async function sendReceiptEmail(recipientEmail: string, receiptUrl: string) {
  const mailOptions = {
    from: process.env.GMAIL_USER,
    to: recipientEmail,
    subject: 'Your Purchase Receipt',
    text: `Thank you for your purchase! You can view your receipt here: ${receiptUrl}`,
    html: `<p>Thank you for your purchase!</p><p>You can view your receipt here: <a href="${receiptUrl}">Receipt</a>.</p>`,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('Receipt email sent successfully:', info.response);
  } catch (error) {
    console.error('Error sending receipt email:', error);
    throw new Error('Failed to send receipt email.');
  }
}// File: apps/api/webhooks/stripe/utils/voucherUtils.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { generateVoucherCode } from '@/utils/voucherCodeGenerator';
import { calculateNewExpiry } from '@/utils/expiryDateCalculator';
import { v4 as uuidv4 } from 'uuid';

// Create or update voucher with idempotency
export async function createOrUpdateVoucher(
  accountNumber: string,
  durationMonths: number,
  paymentIntentId: string
) {
  // Check if a voucher already exists for this payment intent
  const { data: existingVoucher, error: fetchError } = await supabaseAdmin
    .from('vouchers')
    .select('*')
    .eq('payment_intent_id', paymentIntentId)
    .single();

  if (existingVoucher) {
    console.log('Voucher already exists for this payment intent:', existingVoucher.code);
    return;
  }

  const voucherCode = generateVoucherCode();
  const expiryDate = calculateNewExpiry(null, durationMonths); // Returns Date

  const voucherData = {
    id: uuidv4(),
    code: voucherCode,
    duration_months: durationMonths,
    is_used: false,
    associated_account: accountNumber,
    created_at: new Date().toISOString(),
    status: 'active',
    subscription_id: null, // Optionally link to subscription
    channel_id: 'c4c8ca3f-3083-4484-a69c-cd64624ab765', // Default channel ID or dynamically set
    updated_at: new Date().toISOString(),
    used_at: null,
    updated_by: null,
    payment_intent_id: paymentIntentId, // UUID from payment_intents table
  };

  const { error: voucherError } = await supabaseAdmin
    .from('vouchers')
    .insert(voucherData);

  if (voucherError) {
    if (voucherError.code === '23505') { // Unique violation
      console.warn('Voucher already exists during insertion:', voucherData.code);
      return;
    }
    console.error('Error creating voucher:', voucherError.message);
    throw new Error('Failed to create voucher.');
  }

  console.log('Voucher created successfully:', voucherCode);
}
// File: accountHandler.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin'; // Supabase client
import { Database } from '@/types/supabase'; // Import the generated Database type

// Define TypeScript type aliases using Supabase's Database type
type AccountRecord = Database['public']['Tables']['accounts']['Row'];

// Manage user accounts based on user ID
export async function manageAccount(userId: string) {
  console.log(`>>> Managing account for user ID: ${userId}`);

  try {
    // Check if the account already exists
    const { data: account, error: accountError } = await supabaseAdmin
      .from('accounts')
      .select('*')
      .eq('user_id', userId)
      .single();

    if (accountError) {
      // Handle the case where no account is found or another error occurs
      if (accountError.code === 'PGRST116') {
        console.warn(`No account found for user ID ${userId}: ${accountError.message}`);
      } else {
        console.error(`Error fetching account for user ID ${userId}: ${accountError.message}`);
      }
      // Proceed to create a new account since one doesn't exist
    } else if (account) {
      console.log(`Account already exists for user ID: ${userId}`);
      return; // Account exists, no action needed
    }

    // If no account exists, create a new account
    const newAccountData: Omit<AccountRecord, 'id'> = { // Exclude 'id' from the new account data
      account_number: generateUniqueAccountNumber(), // Call your unique account number generation function
      user_id: userId, // Reference the user ID
      status: 'active', // Default status
      max_devices: '5', // Default max devices
      cryptotoken: null, // Default value for cryptotoken
      can_add_ports: 'false', // Default value for can_add_ports
      can_add_devices: 'true', // Default value for can_add_devices
      max_ports: '0', // Default max ports
      expiry: '', // Default expiry
      apple_receipt: null, // Default value for apple_receipt
      apple_api_response: null, // Default value for apple_api_response
      created_at: new Date().toISOString(), // Set to current time
      marked_inactive_by_user: null, // Default value for marked_inactive_by_user
    };

    const { data: createdAccount, error: createError } = await supabaseAdmin
      .from('accounts')
      .insert([newAccountData]);

    if (createError) {
      console.error(`Failed to create account for user ID ${userId}: ${createError.message}`);
    } else {
      console.log(`Successfully created new account for user ID: ${userId}`, createdAccount);
    }
  } catch (error) {
    console.error('Error managing account:', error);
  }
}

// Function to generate a unique account number (adjust as necessary)
function generateUniqueAccountNumber(): string {
  return Math.floor(Math.random() * 10000000000000000).toString(); // Generate a unique number
}// File: handlers/priceSyncHandler.ts

import { stripe } from '@/utils/stripeClient';
import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';
import { v4 as uuidv4 } from 'uuid';

/**
 * Synchronizes Stripe products and their associated prices with Supabase.
 */
export async function syncStripeProductsAndPrices() {
  try {
    console.log('>>> Starting synchronization of Stripe products and prices.');

    // Fetch all active products from Stripe
    const products = await stripe.products.list({
      active: true,
      limit: 100, // Adjust as needed
    });

    for (const product of products.data) {
      // Upsert product into Supabase
      const supabaseProduct: Database['public']['Tables']['products']['Insert'] = {
        id: product.id,
        active: product.active,
        description: product.description || null,
        EAN: product.metadata.EAN || null, // Assuming EAN is stored in metadata
        image: product.images && product.images.length > 0 ? product.images[0] : null,
        ltr_order: product.metadata.ltr_order ? parseInt(product.metadata.ltr_order, 10) : null,
        metadata: product.metadata || {},
        name: product.name || null,
      };

      const { data: upsertedProduct, error: productError } = await supabaseAdmin
        .from('products')
        .upsert(supabaseProduct, { onConflict: 'id' });

      if (productError) {
        console.error(`Failed to upsert product ${product.id}:`, productError.message);
        continue; // Skip to the next product
      }

      console.log(`Product ${product.id} synchronized successfully.`);

      // Fetch prices for the current product
      const prices = await stripe.prices.list({
        product: product.id,
        active: true,
        limit: 100, // Adjust as needed
      });

      for (const price of prices.data) {
        const supabasePrice: Database['public']['Tables']['prices']['Insert'] = {
          id: price.id,
          product_id: product.id,
          active: price.active,
          unit_amount: price.unit_amount || null,
          currency: price.currency || null,
          type: price.type as Database['public']['Enums']['pricing_type'],
          interval: price.recurring?.interval || null,
          interval_count: price.recurring?.interval_count || null,
          trial_period_days: price.recurring?.trial_period_days || null,
          metadata: price.metadata || {},
        };

        const { data: upsertedPrice, error: priceError } = await supabaseAdmin
          .from('prices')
          .upsert(supabasePrice, { onConflict: 'id' });

        if (priceError) {
          console.error(`Failed to upsert price ${price.id}:`, priceError.message);
          continue; // Skip to the next price
        }

        console.log(`Price ${price.id} synchronized successfully.`);
      }
    }

    console.log('>>> Completed synchronization of Stripe products and prices.');
  } catch (error) {
    console.error('Error during synchronization of Stripe products and prices:', error);
  }
}// File: handlers/subscriptionHandler.ts

import { stripe } from '@/utils/stripeClient';
import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';

export type SubscriptionRecord = {
  id: string;
  user_id: string;
  status: string;
  metadata?: any;
  price_id?: string | null;
  quantity?: number | null;
  cancel_at_period_end?: boolean | null;
  created: string;
  current_period_start?: string;
  current_period_end?: string | null;
  ended_at?: string | null;
  cancel_at?: string | null;
  canceled_at?: string | null;
  trial_start?: string | null;
  trial_end?: string | null;
  stripe_subscription_id?: string | null;
  amount?: number | null;
  currency?: string | null;
  description?: string | null;
};

/**
 * Ensures that a specific price exists in Supabase. If not, fetches it from Stripe and inserts it.
 * @param priceId - The Stripe price ID.
 * @returns A boolean indicating whether the price exists after the function executes.
 */
async function ensurePriceExists(priceId: string): Promise<boolean> {
  const { data, error } = await supabaseAdmin
    .from('prices')
    .select('id')
    .eq('id', priceId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') { // Price not found
      console.log(`Price ID ${priceId} not found in Supabase. Fetching from Stripe...`);
      try {
        const price = await stripe.prices.retrieve(priceId);
        const supabasePrice: Database['public']['Tables']['prices']['Insert'] = {
          id: price.id,
          active: price.active,
          currency: price.currency,
          interval: price.recurring?.interval || null,
          interval_count: price.recurring?.interval_count || null,
          metadata: price.metadata || {},
          product_id: price.product as string,
          trial_period_days: price.recurring?.trial_period_days || null,
          type: price.type as Database['public']['Enums']['pricing_type'],
          unit_amount: price.unit_amount || null,
        };

        const { data: insertedData, error: insertError } = await supabaseAdmin
          .from('prices')
          .insert([supabasePrice]);

        if (insertError) {
          console.error(`Failed to insert price ${priceId} into Supabase:`, insertError.message);
          return false;
        }

        console.log(`Price ${priceId} inserted into Supabase successfully.`);
        return true;
      } catch (stripeError) {
        console.error(`Error fetching price ${priceId} from Stripe:`, stripeError);
        return false;
      }
    } else {
      console.error(`Error fetching price ${priceId} from Supabase:`, error.message);
      return false;
    }
  }

  // Price exists
  return true;
}

/**
 * Provisions subscription information in Supabase.
 * @param session - The Stripe Checkout session object.
 * @param userId - The ID of the user in your system.
 */
export async function provisionSubscription(session: any, userId: string, subscriptionId: string | null)  {
  console.log(`>>> Provisioning subscription for session ID: ${session.id}`);

  const amountTotal = session.amount_total;
  const subscriptionValue = session.subscription;

  try {
    // If amount is greater than 0 and there's no subscription, it's a one-time payment (OTP)
    if (amountTotal > 0 && !subscriptionValue) {
      console.log(`>>> Detected one-time payment (OTP). Amount Total: ${amountTotal}`);
      await createOneTimePaymentSubscription(session, userId);
    } else if (subscriptionValue) {
      // If there's a subscription value, fetch the subscription details from Stripe
      const subscription = await stripe.subscriptions.retrieve(subscriptionValue);
      console.log(`>>> Retrieved subscription from Stripe:`, subscription);

      const priceId = subscription.items.data[0]?.price.id || null;

      if (priceId) {
        // Ensure that the price exists in Supabase, if not, insert it
        const priceExists = await ensurePriceExists(priceId);
        if (!priceExists) {
          throw new Error(`Price ID ${priceId} does not exist in Supabase after synchronization.`);
        }
      }

      // Prepare the subscription data to be inserted into Supabase
      const subscriptionData: SubscriptionRecord = {
        id: subscriptionValue, // Use the subscription value as the ID
        user_id: userId,
        status: subscription.status as any,
        metadata: subscription.metadata || null,
        price_id: subscription.items.data[0]?.price.id || null,
        quantity: subscription.items.data[0]?.quantity || 1,
        cancel_at_period_end: subscription.cancel_at_period_end || false,
        created: new Date(subscription.created * 1000).toISOString(),
        current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
        current_period_end: subscription.current_period_end
          ? new Date(subscription.current_period_end * 1000).toISOString()
          : null,
        ended_at: subscription.ended_at ? new Date(subscription.ended_at * 1000).toISOString() : null,
        cancel_at: subscription.cancel_at ? new Date(subscription.cancel_at * 1000).toISOString() : null,
        canceled_at: subscription.canceled_at ? new Date(subscription.canceled_at * 1000).toISOString() : null,
        trial_start: subscription.trial_start ? new Date(subscription.trial_start * 1000).toISOString() : null,
        trial_end: subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,
        stripe_subscription_id: subscription.id,
        amount: amountTotal || null,
        currency: session.currency || null,
        description: null,
      };

      console.log(`>>> Inserting subscription data into Supabase:`, subscriptionData);
      const { data, error } = await supabaseAdmin
        .from('subscriptions')
        .insert([subscriptionData]);

      if (error) {
        console.error(`Failed to insert subscription data: ${error.message}`);
      } else {
        console.log(`Successfully inserted subscription ${subscription.id}.`);
      }
    } else {
      console.warn(`No valid subscription ID found, skipping provisioning.`);
    }
  } catch (error) {
    console.error('Error provisioning subscription:', error);
  }
}

/**
 * Creates a one-time payment subscription in Supabase.
 * @param session - The Stripe Checkout session object.
 * @param userId - The ID of the user in your system.
 */
async function createOneTimePaymentSubscription(session: any, userId: string) {
  try {
    // Prepare the data for the one-time payment subscription to be inserted into Supabase
    const otpSubscriptionData: SubscriptionRecord = {
      id: session.subscription || `otp_${Date.now()}`, // Use subscription value if available, otherwise generate a temporary ID
      user_id: userId, // Use the retrieved user ID
      status: 'one_time_purchase', // Status for one-time purchases
      metadata: session.metadata || null,
      price_id: null, // No price ID for OTP
      quantity: 1, // Quantity for one-time purchase
      cancel_at_period_end: false,
      created: new Date(session.created * 1000).toISOString(),
      current_period_start: new Date(session.created * 1000).toISOString(),
      current_period_end: null, // No specific end for OTP
      ended_at: null,
      cancel_at: null,
      canceled_at: null,
      trial_start: null,
      trial_end: null,
      stripe_subscription_id: null, // No Stripe subscription ID for OTP
      amount: session.amount_total || 0, // Use the amount total from the session
      currency: session.currency || null, // Set currency based on session data
      description: null, // Optional description field
    };

    console.log(`>>> Inserting one-time payment subscription data into Supabase:`, otpSubscriptionData);
    const { data, error } = await supabaseAdmin
      .from('subscriptions')
      .insert([otpSubscriptionData]);

    if (error) {
      console.error(`Failed to insert one-time payment subscription: ${error.message}`);
    } else {
      console.log(`Successfully inserted one-time payment subscription.`);
    }
  } catch (error) {
    console.error('Error creating one-time payment subscription:', error);
  }
}
// File: handlers/voucherHandler.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { Database } from '@/types/supabase';

/**
 * Defines the structure of a Voucher.
 */
type VoucherRecord = Database['public']['Tables']['vouchers']['Row'];

/**
 * Generates a unique 16-digit integer voucher code.
 * @returns A unique 16-digit voucher code string.
 */
function generateVoucherCode(): string {
  // Generate a random 16-digit integer as a string
  let code = '';
  for (let i = 0; i < 16; i++) {
    code += Math.floor(Math.random() * 10).toString();
  }
  return code;
}

/**
 * Generates a unique voucher code ensuring no duplication in the database.
 * @returns A unique 16-digit voucher code string.
 */
async function generateUniqueVoucherCode(): Promise<string> {
  let isUnique = false;
  let code = '';

  while (!isUnique) {
    code = generateVoucherCode();
    // Check if the code already exists
    const { data, error } = await supabaseAdmin
      .from('vouchers')
      .select('id')
      .eq('code', code)
      .single();

    if (error && error.code === 'PGRST116') {
      // Code is unique
      isUnique = true;
    } else {
      // Code already exists or another error occurred
      console.warn(`Voucher code ${code} already exists or an error occurred. Generating a new one.`);
    }
  }

  return code;
}

/**
 * Creates and assigns a voucher to the user's associated account.
 * @param userId - The ID of the user.
 * @param durationMonths - The duration in months for the voucher.
 * @param subscriptionId - The Stripe subscription ID associated with the purchase (optional).
 */
export async function createAndAssignVoucher(
  userId: string,
  durationMonths: number,
  subscriptionId: string | null = null
) {
  try {
    console.log(`>>> Creating voucher for user ID: ${userId} with duration: ${durationMonths} months`);

    // Generate a unique 16-digit voucher code
    const voucherCode = await generateUniqueVoucherCode();

    // Retrieve the user's associated account with account_number
    const { data: account, error: accountError } = await supabaseAdmin
      .from('accounts')
      .select('account_number, expiry')
      .eq('user_id', userId)
      .single();

    if (accountError) {
      console.error(`Error fetching account for user ID ${userId}:`, accountError.message);
      throw new Error('Failed to retrieve user account.');
    }

    if (!account) {
      console.error(`No account found for user ID ${userId}.`);
      throw new Error('User account does not exist.');
    }

    // Calculate the new expiry date by adding durationMonths
    const currentExpiry = new Date(account.expiry);
    const newExpiry = new Date(currentExpiry);
    newExpiry.setMonth(newExpiry.getMonth() + durationMonths);

    // Prepare the new voucher data
    const newVoucher: Omit<VoucherRecord, 'id' | 'created_at' | 'updated_at'> = {
      associated_account: account.account_number, // Correctly reference account_number
      channel_id: null, // Set accordingly if needed
      code: voucherCode,
      duration_months: durationMonths,
      is_used: true, // Mark as used immediately
      payment_intent_id: null, // Set accordingly if needed
      status: 'active', // Adjust based on your business logic
      subscription_id: subscriptionId, // Set based on the parameter
      updated_by: null,
      used_at: new Date().toISOString(),
      // Add other fields if necessary
    };

    // Insert the new voucher
    const { data: insertedVoucher, error: insertError } = await supabaseAdmin
      .from('vouchers')
      .insert([newVoucher]);

    if (insertError) {
      console.error('Error inserting voucher:', insertError.message);
      throw new Error('Failed to insert voucher.');
    }

    console.log(`>>> Successfully created and assigned voucher ${voucherCode} to account ${account.account_number}.`);

    // Update the account's expiry date
    const { error: updateError } = await supabaseAdmin
      .from('accounts')
      .update({ expiry: newExpiry.toISOString() })
      .eq('account_number', account.account_number); // Ensure to match account_number

    if (updateError) {
      console.error(`Error updating expiry for account number ${account.account_number}:`, updateError.message);
      throw new Error('Failed to update account expiry.');
    }

    console.log(`>>> Updated account ${account.account_number} expiry to ${newExpiry.toISOString()}.`);
  } catch (error) {
    console.error('>>> Error in createAndAssignVoucher:', error);
    throw error; // Re-throw the error after logging
  }
}// File: handlers/webhookHandler.ts

import { stripe } from '@/utils/stripeClient'; // Centralized Stripe instance
import { supabaseAdmin, getUserByEmail, createUser } from '@/utils/supabaseAdmin'; 
import { v4 as uuidv4 } from 'uuid';
import { Database } from '@/types/supabase'; // Import the generated Database type
import { provisionSubscription } from './subscriptionHandler'; // Import the provisionSubscription function
import { manageAccount } from './accountHandler'; // Import manageAccount function
import { sendReceiptEmail } from '@/app/api/webhooks/stripe/utils/emailUtils'; // Import the new email function

// Define TypeScript type aliases using Supabase's Database type
type CustomerRecord = Database['public']['Tables']['customers']['Row'];

// Handle 'checkout.session.completed' event
async function handleCheckoutCompleted(session) {
  // Log the raw session data received from Stripe for debugging
  console.log('>>> Raw session data received from Stripe:', JSON.stringify(session, null, 2));

  const customerEmail = session.customer_email ?? session.customer_details?.email ?? null;
  const fullName = session.customer_details?.name ?? null; 
  const profilePicUrl = session.customer_details?.image ?? null; // Assuming image is the field for profile picture

  console.log(`>>> Processing checkout.session.completed for email: ${customerEmail}`);

  if (!customerEmail) {
    console.warn('No customer email found in checkout.session.completed event.');
    return; // Exit early since email is essential
  }

  try {
    // Check if the user already exists
    const existingUser = await getUserByEmail(customerEmail);

    let userId: string | undefined; // Initialize userId

    if (existingUser) {
      console.log(`User already exists in auth.users: ${existingUser.id}`);
      userId = existingUser.id; // Store userId for later use
      // Update user information if needed, including profile picture
      await syncPublicUser(existingUser.id, customerEmail, fullName, profilePicUrl);
    } else {
      // If user does not exist, provision the new user
      const newPassword = uuidv4(); // Generate a new UUID for the password
      console.log(`Creating new user with email: ${customerEmail}`);
      const newUser = await createUser(customerEmail, newPassword);

      if (newUser) {
        console.log(`New user created: ${newUser.id}`);
        userId = newUser.id; // Store userId for later use
        // Sync the new user profile
        await syncPublicUser(newUser.id, customerEmail, fullName, profilePicUrl);
      } else {
        console.error('Failed to create a new user.');
        return; // Exit if user creation fails
      }
    }

    // Manage account for the user
    await manageAccount(userId); // Ensure the account is created or verified

    // Now provision the subscription based on the session
    await provisionSubscription(session, userId); // Pass both session and userId

  } catch (error) {
    console.error('Error processing checkout.session.completed:', error);
  }
}

// Handle other (unhandled) events
async function handleUnhandledEvent(event) {
  console.warn(`Unhandled event type: ${event.type}`);
}

// Sync user data to public.users table
async function syncPublicUser(userId: string, email: string | null, fullName: string | null, profilePicUrl: string | null) {
  if (!email) {
    console.warn(`Cannot sync public user without email for user ID: ${userId}`);
    return;
  }

  try {
    console.log(`>>> Upserting user profile in 'users' table for user ID: ${userId}`);
    const { data, error } = await supabaseAdmin
      .from('users') // Ensure this matches your Supabase table
      .upsert(
        { id: userId, email: email, full_name: fullName, avatar_url: profilePicUrl }, // Include profilePicUrl
        { onConflict: 'id' } // Ensure no duplicate entries
      );

    if (error) {
      console.error(`Failed to sync user profile for user ID ${userId}: ${error.message}`);
    } else {
      console.log(`User profile synced successfully for user ID: ${userId}.`);
    }
  } catch (error) {
    console.error(`Error in syncPublicUser for user ID ${userId}:`, error);
  }
}

// Handle 'charge.succeeded' event
async function handleChargeSucceeded(charge) {
  console.log('>>> Processing charge.succeeded event.');

  const receiptUrl = charge.receipt_url;
  const customerEmail = charge.receipt_email || charge.billing_details?.email;

  if (!customerEmail) {
    console.warn('No customer email found in charge.succeeded event.');
    return;
  }

  if (!receiptUrl) {
    console.warn('No receipt URL found in charge.succeeded event.');
    return;
  }

  try {
    // Send the receipt email
    await sendReceiptEmail(customerEmail, receiptUrl);
    console.log(`>>> Receipt email sent to ${customerEmail}`);
  } catch (error) {
    console.error('Error sending receipt email:', error);
  }
}

// Export the event handler function
export async function handleWebhookEvent(event) {
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object);
      break;
    case 'charge.succeeded':
      await handleChargeSucceeded(event.data.object);
      break;
    // Add additional cases for other events as needed
    default:
      await handleUnhandledEvent(event);
      break;
  }
}// File: apps/api/webhooks/stripe/utils/emailUtils.ts

import nodemailer from 'nodemailer';

// Initialize Nodemailer transporter with OAuth2 for enhanced security
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    type: 'OAuth2',
    user: process.env.GMAIL_USER,
    clientId: process.env.GMAIL_CLIENT_ID,
    clientSecret: process.env.GMAIL_CLIENT_SECRET,
    refreshToken: process.env.GMAIL_REFRESH_TOKEN,
  },
});

/**
 * Send a general email notification to the customer.
 * @param recipientEmail - The customer's email address.
 * @param sessionId - The Stripe Checkout session ID.
 */
export async function sendEmailNotification(recipientEmail: string, sessionId: string) {
  const mailOptions = {
    from: process.env.GMAIL_USER,
    to: recipientEmail,
    subject: 'Payment Confirmation',
    text: `Thank you for your purchase! Your session ID is: ${sessionId}.`,
    html: `<p>Thank you for your purchase!</p><p>Your session ID is: <strong>${sessionId}</strong>.</p>`,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('Email sent successfully:', info.response);
  } catch (error) {
    console.error('Error sending email:', error);
    throw new Error('Failed to send email.');
  }
}

/**
 * Send a receipt email to the customer with the receipt link.
 * @param recipientEmail - The customer's email address.
 * @param receiptUrl - The URL to the receipt.
 */
export async function sendReceiptEmail(recipientEmail: string, receiptUrl: string) {
  const mailOptions = {
    from: process.env.GMAIL_USER,
    to: recipientEmail,
    subject: 'Your Purchase Receipt',
    text: `Thank you for your purchase! You can view your receipt here: ${receiptUrl}`,
    html: `<p>Thank you for your purchase!</p><p>You can view your receipt here: <a href="${receiptUrl}">Receipt</a>.</p>`,
  };

  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('Receipt email sent successfully:', info.response);
  } catch (error) {
    console.error('Error sending receipt email:', error);
    throw new Error('Failed to send receipt email.');
  }
}// File: apps/api/webhooks/stripe/utils/voucherUtils.ts

import { supabaseAdmin } from '@/utils/supabaseAdmin';
import { generateVoucherCode } from '@/utils/voucherCodeGenerator';
import { calculateNewExpiry } from '@/utils/expiryDateCalculator';
import { v4 as uuidv4 } from 'uuid';

// Create or update voucher with idempotency
export async function createOrUpdateVoucher(
  accountNumber: string,
  durationMonths: number,
  paymentIntentId: string
) {
  // Check if a voucher already exists for this payment intent
  const { data: existingVoucher, error: fetchError } = await supabaseAdmin
    .from('vouchers')
    .select('*')
    .eq('payment_intent_id', paymentIntentId)
    .single();

  if (existingVoucher) {
    console.log('Voucher already exists for this payment intent:', existingVoucher.code);
    return;
  }

  const voucherCode = generateVoucherCode();
  const expiryDate = calculateNewExpiry(null, durationMonths); // Returns Date

  const voucherData = {
    id: uuidv4(),
    code: voucherCode,
    duration_months: durationMonths,
    is_used: false,
    associated_account: accountNumber,
    created_at: new Date().toISOString(),
    status: 'active',
    subscription_id: null, // Optionally link to subscription
    channel_id: 'c4c8ca3f-3083-4484-a69c-cd64624ab765', // Default channel ID or dynamically set
    updated_at: new Date().toISOString(),
    used_at: null,
    updated_by: null,
    payment_intent_id: paymentIntentId, // UUID from payment_intents table
  };

  const { error: voucherError } = await supabaseAdmin
    .from('vouchers')
    .insert(voucherData);

  if (voucherError) {
    if (voucherError.code === '23505') { // Unique violation
      console.warn('Voucher already exists during insertion:', voucherData.code);
      return;
    }
    console.error('Error creating voucher:', voucherError.message);
    throw new Error('Failed to create voucher.');
  }

  console.log('Voucher created successfully:', voucherCode);
}
// File: app/api/webhooks/stripe/route.ts

import { NextResponse } from 'next/server';
import { handleWebhookEvent } from './handlers/webhookHandler';
import { stripe, isProduction } from '@/utils/stripeClient';
import type { NextRequest } from 'next/server';

// Webhook handler
export async function POST(req: NextRequest) {
  const sig = req.headers.get('stripe-signature');

  if (!sig) {
    console.error('Missing Stripe signature.');
    return NextResponse.json({ error: 'Missing Stripe signature.' }, { status: 400 });
  }

  // Select the appropriate webhook secret based on the environment
  const webhookSecret = isProduction
    ? process.env.STRIPE_LIVE_WEBHOOK_SECRET!
    : process.env.STRIPE_TEST_WEBHOOK_SECRET!;

  let event;

  try {
    const body = await req.text(); // Retrieve the raw request body
    event = stripe.webhooks.constructEvent(body, sig, webhookSecret);
    console.log(`Webhook signature verified. Event ID: ${event.id}`);
  } catch (err: any) {
    console.error(`  Webhook signature verification failed: ${err.message}`);
    return NextResponse.json({ error: `Webhook Error: ${err.message}` }, { status: 400 });
  }

  try {
    await handleWebhookEvent(event);
    return NextResponse.json({ received: true }, { status: 200 });
  } catch (error) {
    console.error(`  Error handling webhook event: ${error instanceof Error ? error.message : error}`);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}