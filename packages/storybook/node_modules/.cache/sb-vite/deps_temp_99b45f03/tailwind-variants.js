import {
  extendTailwindMerge,
  twMerge
} from "./chunk-CUAH6VXV.js";
import "./chunk-AUZ3RYOM.js";

// ../../node_modules/.pnpm/tailwind-variants@0.1.20_tailwindcss@3.4.10_ts-node@10.9.2_@swc+core@1.7.24_@swc+helpers@0.5._c3v56o2bzwbvbxv7rxumpdt3si/node_modules/tailwind-variants/dist/chunk-JXBJZR5A.js
var l = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e;
var u = (e) => !e || typeof e != "object" || Object.keys(e).length === 0;
var x = (e, o) => JSON.stringify(e) === JSON.stringify(o);
function i(e, o) {
  e.forEach(function(r) {
    Array.isArray(r) ? i(r, o) : o.push(r);
  });
}
function y(e) {
  let o = [];
  return i(e, o), o;
}
var a = (...e) => y(e).filter(Boolean);
var p = (e, o) => {
  let r = {}, c = Object.keys(e), f = Object.keys(o);
  for (let t of c)
    if (f.includes(t)) {
      let s = e[t], n = o[t];
      typeof s == "object" && typeof n == "object" ? r[t] = p(s, n) : Array.isArray(s) || Array.isArray(n) ? r[t] = a(n, s) : r[t] = n + " " + s;
    } else
      r[t] = e[t];
  for (let t of f)
    c.includes(t) || (r[t] = o[t]);
  return r;
};
var g = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();

// ../../node_modules/.pnpm/tailwind-variants@0.1.20_tailwindcss@3.4.10_ts-node@10.9.2_@swc+core@1.7.24_@swc+helpers@0.5._c3v56o2bzwbvbxv7rxumpdt3si/node_modules/tailwind-variants/dist/index.js
var se = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
var _ = (s) => s || void 0;
var N = (...s) => _(y(s).filter(Boolean).join(" "));
var q = null;
var M = {};
var F = false;
var w = (...s) => (b$1) => b$1.twMerge ? ((!q || F) && (F = false, q = u(M) ? twMerge : extendTailwindMerge(M)), _(q(N(s)))) : N(s);
var Z = (s, b) => {
  for (let e in b)
    s.hasOwnProperty(e) ? s[e] = N(s[e], b[e]) : s[e] = b[e];
  return s;
};
var ie = (s, b$1) => {
  let { extend: e = null, slots: j = {}, variants: U = {}, compoundVariants: C = [], compoundSlots: V = [], defaultVariants: W = {} } = s, m = { ...se, ...b$1 }, S = e != null && e.base ? N(e.base, s == null ? void 0 : s.base) : s == null ? void 0 : s.base, g$1 = e != null && e.variants && !u(e.variants) ? p(U, e.variants) : U, A = e != null && e.defaultVariants && !u(e.defaultVariants) ? { ...e.defaultVariants, ...W } : W;
  !u(m.twMergeConfig) && !x(m.twMergeConfig, M) && (F = true, M = m.twMergeConfig);
  let O = u(e == null ? void 0 : e.slots), $ = u(j) ? {} : { base: N(s == null ? void 0 : s.base, O && (e == null ? void 0 : e.base)), ...j }, h$1 = O ? $ : Z({ ...e == null ? void 0 : e.slots }, u($) ? { base: s == null ? void 0 : s.base } : $), v = (l2) => {
    if (u(g$1) && u(j) && O)
      return w(S, l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
    if (C && !Array.isArray(C))
      throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof C}`);
    if (V && !Array.isArray(V))
      throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof V}`);
    let K = (t, n, a2 = [], i2) => {
      let r = a2;
      if (typeof n == "string")
        r = r.concat(g(n).split(" ").map((c) => `${t}:${c}`));
      else if (Array.isArray(n))
        r = r.concat(n.reduce((c, f) => c.concat(`${t}:${f}`), []));
      else if (typeof n == "object" && typeof i2 == "string") {
        for (let c in n)
          if (n.hasOwnProperty(c) && c === i2) {
            let f = n[c];
            if (f && typeof f == "string") {
              let o = g(f);
              r[i2] ? r[i2] = r[i2].concat(o.split(" ").map((u2) => `${t}:${u2}`)) : r[i2] = o.split(" ").map((u2) => `${t}:${u2}`);
            } else
              Array.isArray(f) && f.length > 0 && (r[i2] = f.reduce((o, u2) => o.concat(`${t}:${u2}`), []));
          }
      }
      return r;
    }, z = (t, n = g$1, a$1 = null, i2 = null) => {
      var J;
      let r = n[t];
      if (!r || u(r))
        return null;
      let c = (J = i2 == null ? void 0 : i2[t]) != null ? J : l2 == null ? void 0 : l2[t];
      if (c === null)
        return null;
      let f = l(c), o = Array.isArray(m.responsiveVariants) && m.responsiveVariants.length > 0 || m.responsiveVariants === true, u2 = A == null ? void 0 : A[t], d = [];
      if (typeof f == "object" && o)
        for (let [k, L] of Object.entries(f)) {
          let ae = r[L];
          if (k === "initial") {
            u2 = L;
            continue;
          }
          Array.isArray(m.responsiveVariants) && !m.responsiveVariants.includes(k) || (d = K(k, ae, d, a$1));
        }
      let T = r[f] || r[l(u2)];
      return typeof d == "object" && typeof a$1 == "string" && d[a$1] ? Z(d, T) : d.length > 0 ? (d.push(T), d) : T;
    }, P = () => g$1 ? Object.keys(g$1).map((t) => z(t, g$1)) : null, p2 = (t, n) => {
      if (!g$1 || typeof g$1 != "object")
        return null;
      let a2 = new Array();
      for (let i2 in g$1) {
        let r = z(i2, g$1, t, n), c = t === "base" && typeof r == "string" ? r : r && r[t];
        c && (a2[a2.length] = c);
      }
      return a2;
    }, D = {};
    for (let t in l2)
      l2[t] !== void 0 && (D[t] = l2[t]);
    let G = (t, n) => {
      var i2;
      let a2 = typeof (l2 == null ? void 0 : l2[t]) == "object" ? { [t]: (i2 = l2[t]) == null ? void 0 : i2.initial } : {};
      return { ...A, ...D, ...a2, ...n };
    }, H = (t = [], n) => {
      let a2 = [];
      for (let { class: i2, className: r, ...c } of t) {
        let f = true;
        for (let [o, u2] of Object.entries(c)) {
          let d = G(o, n);
          if (Array.isArray(u2)) {
            if (!u2.includes(d[o])) {
              f = false;
              break;
            }
          } else if (d[o] !== u2) {
            f = false;
            break;
          }
        }
        f && (i2 && a2.push(i2), r && a2.push(r));
      }
      return a2;
    }, I = (t) => {
      let n = H(C, t), a2 = H(e == null ? void 0 : e.compoundVariants, t);
      return a(a2, n);
    }, ee = (t) => {
      let n = I(t);
      if (!Array.isArray(n))
        return n;
      let a2 = {};
      for (let i2 of n)
        if (typeof i2 == "string" && (a2.base = w(a2.base, i2)(m)), typeof i2 == "object")
          for (let [r, c] of Object.entries(i2))
            a2[r] = w(a2[r], c)(m);
      return a2;
    }, te = (t) => {
      if (V.length < 1)
        return null;
      let n = {};
      for (let { slots: a2 = [], class: i2, className: r, ...c } of V) {
        if (!u(c)) {
          let f = true;
          for (let o of Object.keys(c)) {
            let u2 = G(o, t)[o];
            if (u2 === void 0 || (Array.isArray(c[o]) ? !c[o].includes(u2) : c[o] !== u2)) {
              f = false;
              break;
            }
          }
          if (!f)
            continue;
        }
        for (let f of a2)
          n[f] = n[f] || [], n[f].push([i2, r]);
      }
      return n;
    };
    if (!u(j) || !O) {
      let t = {};
      if (typeof h$1 == "object" && !u(h$1))
        for (let n of Object.keys(h$1))
          t[n] = (a2) => {
            var i2, r;
            return w(h$1[n], p2(n, a2), ((i2 = ee(a2)) != null ? i2 : [])[n], ((r = te(a2)) != null ? r : [])[n], a2 == null ? void 0 : a2.class, a2 == null ? void 0 : a2.className)(m);
          };
      return t;
    }
    return w(S, P(), I(), l2 == null ? void 0 : l2.class, l2 == null ? void 0 : l2.className)(m);
  }, x2 = () => {
    if (!(!g$1 || typeof g$1 != "object"))
      return Object.keys(g$1);
  };
  return v.variantKeys = x2(), v.extend = e, v.base = S, v.slots = h$1, v.variants = g$1, v.defaultVariants = A, v.compoundSlots = V, v.compoundVariants = C, v;
};
var le = (s) => (b, e) => ie(b, e ? p(s, e) : s);
export {
  w as cn,
  N as cnBase,
  le as createTV,
  se as defaultConfig,
  ie as tv,
  _ as voidEmpty
};
//# sourceMappingURL=tailwind-variants.js.map
