import {
  require_react
} from "./chunk-74VSPVB3.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// ../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/useListData.mjs
var import_react = __toESM(require_react(), 1);
function $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {
  let { initialItems = [], initialSelectedKeys, getKey = (item) => item.id || item.key, filter, initialFilterText = "" } = options;
  let [state, setState] = (0, import_react.useState)({
    items: initialItems,
    selectedKeys: initialSelectedKeys === "all" ? "all" : new Set(initialSelectedKeys || []),
    filterText: initialFilterText
  });
  let filteredItems = (0, import_react.useMemo)(() => filter ? state.items.filter((item) => filter(item, state.filterText)) : state.items, [
    state.items,
    state.filterText,
    filter
  ]);
  return {
    ...state,
    items: filteredItems,
    ...$0d86e9c8f07f9a7b$export$79c0c687a5963b0a({
      getKey
    }, setState),
    getItem(key) {
      return state.items.find((item) => getKey(item) === key);
    }
  };
}
function $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {
  let { cursor, getKey } = opts;
  return {
    setSelectedKeys(selectedKeys) {
      dispatch((state) => ({
        ...state,
        selectedKeys
      }));
    },
    setFilterText(filterText) {
      dispatch((state) => ({
        ...state,
        filterText
      }));
    },
    insert(index, ...values) {
      dispatch((state) => $0d86e9c8f07f9a7b$var$insert(state, index, ...values));
    },
    insertBefore(key, ...values) {
      dispatch((state) => {
        let index = state.items.findIndex((item) => getKey(item) === key);
        if (index === -1) {
          if (state.items.length === 0)
            index = 0;
          else
            return state;
        }
        return $0d86e9c8f07f9a7b$var$insert(state, index, ...values);
      });
    },
    insertAfter(key, ...values) {
      dispatch((state) => {
        let index = state.items.findIndex((item) => getKey(item) === key);
        if (index === -1) {
          if (state.items.length === 0)
            index = 0;
          else
            return state;
        }
        return $0d86e9c8f07f9a7b$var$insert(state, index + 1, ...values);
      });
    },
    prepend(...values) {
      dispatch((state) => $0d86e9c8f07f9a7b$var$insert(state, 0, ...values));
    },
    append(...values) {
      dispatch((state) => $0d86e9c8f07f9a7b$var$insert(state, state.items.length, ...values));
    },
    remove(...keys) {
      dispatch((state) => {
        let keySet = new Set(keys);
        let items = state.items.filter((item) => !keySet.has(getKey(item)));
        let selection = "all";
        if (state.selectedKeys !== "all") {
          selection = new Set(state.selectedKeys);
          for (let key of keys)
            selection.delete(key);
        }
        if (cursor == null && items.length === 0)
          selection = /* @__PURE__ */ new Set();
        return {
          ...state,
          items,
          selectedKeys: selection
        };
      });
    },
    removeSelectedItems() {
      dispatch((state) => {
        if (state.selectedKeys === "all")
          return {
            ...state,
            items: [],
            selectedKeys: /* @__PURE__ */ new Set()
          };
        let selectedKeys = state.selectedKeys;
        let items = state.items.filter((item) => !selectedKeys.has(getKey(item)));
        return {
          ...state,
          items,
          selectedKeys: /* @__PURE__ */ new Set()
        };
      });
    },
    move(key, toIndex) {
      dispatch((state) => {
        let index = state.items.findIndex((item2) => getKey(item2) === key);
        if (index === -1)
          return state;
        let copy = state.items.slice();
        let [item] = copy.splice(index, 1);
        copy.splice(toIndex, 0, item);
        return {
          ...state,
          items: copy
        };
      });
    },
    moveBefore(key, keys) {
      dispatch((state) => {
        let toIndex = state.items.findIndex((item) => getKey(item) === key);
        if (toIndex === -1)
          return state;
        let keyArray = Array.isArray(keys) ? keys : [
          ...keys
        ];
        let indices = keyArray.map((key2) => state.items.findIndex((item) => getKey(item) === key2)).sort((a, b) => a - b);
        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);
      });
    },
    moveAfter(key, keys) {
      dispatch((state) => {
        let toIndex = state.items.findIndex((item) => getKey(item) === key);
        if (toIndex === -1)
          return state;
        let keyArray = Array.isArray(keys) ? keys : [
          ...keys
        ];
        let indices = keyArray.map((key2) => state.items.findIndex((item) => getKey(item) === key2)).sort((a, b) => a - b);
        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);
      });
    },
    update(key, newValue) {
      dispatch((state) => {
        let index = state.items.findIndex((item) => getKey(item) === key);
        if (index === -1)
          return state;
        return {
          ...state,
          items: [
            ...state.items.slice(0, index),
            newValue,
            ...state.items.slice(index + 1)
          ]
        };
      });
    }
  };
}
function $0d86e9c8f07f9a7b$var$insert(state, index, ...values) {
  return {
    ...state,
    items: [
      ...state.items.slice(0, index),
      ...values,
      ...state.items.slice(index)
    ]
  };
}
function $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {
  toIndex -= indices.filter((index) => index < toIndex).length;
  let moves = indices.map((from) => ({
    from,
    to: toIndex++
  }));
  for (let i = 0; i < moves.length; i++) {
    let a = moves[i].from;
    for (let j = i; j < moves.length; j++) {
      let b = moves[j].from;
      if (b > a)
        moves[j].from--;
    }
  }
  for (let i = 0; i < moves.length; i++) {
    let a = moves[i];
    for (let j = moves.length - 1; j > i; j--) {
      let b = moves[j];
      if (b.from < a.to)
        a.to++;
      else
        b.from++;
    }
  }
  let copy = state.items.slice();
  for (let move of moves) {
    let [item] = copy.splice(move.from, 1);
    copy.splice(move.to, 0, item);
  }
  return {
    ...state,
    items: copy
  };
}

// ../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/useAsyncList.mjs
var import_react2 = __toESM(require_react(), 1);
function $f86e6c1ec7da6ebb$var$reducer(data, action) {
  let selectedKeys;
  switch (data.state) {
    case "idle":
    case "error":
      switch (action.type) {
        case "loading":
        case "loadingMore":
        case "sorting":
        case "filtering":
          var _action_filterText, _action_sortDescriptor;
          return {
            ...data,
            filterText: (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText,
            state: action.type,
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === "loading" ? [] : data.items,
            sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,
            abortController: action.abortController
          };
        case "update":
          return {
            ...data,
            ...action.updater(data)
          };
        case "success":
        case "error":
          return data;
        default:
          throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
      }
    case "loading":
    case "sorting":
    case "filtering":
      switch (action.type) {
        case "success":
          if (action.abortController !== data.abortController)
            return data;
          var _action_selectedKeys;
          selectedKeys = (_action_selectedKeys = action.selectedKeys) !== null && _action_selectedKeys !== void 0 ? _action_selectedKeys : data.selectedKeys;
          var _action_filterText1, _action_sortDescriptor1;
          return {
            ...data,
            filterText: (_action_filterText1 = action.filterText) !== null && _action_filterText1 !== void 0 ? _action_filterText1 : data.filterText,
            state: "idle",
            items: [
              ...action.items
            ],
            selectedKeys: selectedKeys === "all" ? "all" : new Set(selectedKeys),
            sortDescriptor: (_action_sortDescriptor1 = action.sortDescriptor) !== null && _action_sortDescriptor1 !== void 0 ? _action_sortDescriptor1 : data.sortDescriptor,
            abortController: null,
            cursor: action.cursor
          };
        case "error":
          if (action.abortController !== data.abortController)
            return data;
          return {
            ...data,
            state: "error",
            error: action.error,
            abortController: null
          };
        case "loading":
        case "loadingMore":
        case "sorting":
        case "filtering":
          data.abortController.abort();
          var _action_filterText2;
          return {
            ...data,
            filterText: (_action_filterText2 = action.filterText) !== null && _action_filterText2 !== void 0 ? _action_filterText2 : data.filterText,
            state: action.type,
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === "loading" ? [] : data.items,
            abortController: action.abortController
          };
        case "update":
          return {
            ...data,
            ...action.updater(data)
          };
        default:
          throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
      }
    case "loadingMore":
      switch (action.type) {
        case "success":
          var _action_selectedKeys1;
          selectedKeys = data.selectedKeys === "all" || action.selectedKeys === "all" ? "all" : /* @__PURE__ */ new Set([
            ...data.selectedKeys,
            ...(_action_selectedKeys1 = action.selectedKeys) !== null && _action_selectedKeys1 !== void 0 ? _action_selectedKeys1 : []
          ]);
          var _action_sortDescriptor2;
          return {
            ...data,
            state: "idle",
            items: [
              ...data.items,
              ...action.items
            ],
            selectedKeys,
            sortDescriptor: (_action_sortDescriptor2 = action.sortDescriptor) !== null && _action_sortDescriptor2 !== void 0 ? _action_sortDescriptor2 : data.sortDescriptor,
            abortController: null,
            cursor: action.cursor
          };
        case "error":
          if (action.abortController !== data.abortController)
            return data;
          return {
            ...data,
            state: "error",
            error: action.error
          };
        case "loading":
        case "sorting":
        case "filtering":
          data.abortController.abort();
          var _action_filterText3;
          return {
            ...data,
            filterText: (_action_filterText3 = action.filterText) !== null && _action_filterText3 !== void 0 ? _action_filterText3 : data.filterText,
            state: action.type,
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === "loading" ? [] : data.items,
            abortController: action.abortController
          };
        case "loadingMore":
          action.abortController.abort();
          return data;
        case "update":
          return {
            ...data,
            ...action.updater(data)
          };
        default:
          throw new Error(`Invalid action "${action.type}" in state "${data.state}"`);
      }
    default:
      throw new Error(`Invalid state "${data.state}"`);
  }
}
function $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {
  const { load, sort, initialSelectedKeys, initialSortDescriptor, getKey = (item) => item.id || item.key, initialFilterText = "" } = options;
  let [data, dispatch] = (0, import_react2.useReducer)($f86e6c1ec7da6ebb$var$reducer, {
    state: "idle",
    error: null,
    items: [],
    selectedKeys: initialSelectedKeys === "all" ? "all" : new Set(initialSelectedKeys),
    sortDescriptor: initialSortDescriptor,
    filterText: initialFilterText
  });
  const dispatchFetch = async (action, fn) => {
    let abortController = new AbortController();
    try {
      dispatch({
        ...action,
        abortController
      });
      var _action_filterText;
      let previousFilterText = (_action_filterText = action.filterText) !== null && _action_filterText !== void 0 ? _action_filterText : data.filterText;
      var _action_sortDescriptor;
      let response = await fn({
        items: data.items.slice(),
        selectedKeys: data.selectedKeys,
        sortDescriptor: (_action_sortDescriptor = action.sortDescriptor) !== null && _action_sortDescriptor !== void 0 ? _action_sortDescriptor : data.sortDescriptor,
        signal: abortController.signal,
        cursor: action.type === "loadingMore" ? data.cursor : null,
        filterText: previousFilterText
      });
      var _response_filterText;
      let filterText = (_response_filterText = response.filterText) !== null && _response_filterText !== void 0 ? _response_filterText : previousFilterText;
      dispatch({
        type: "success",
        ...response,
        abortController
      });
      if (filterText && filterText !== previousFilterText && !abortController.signal.aborted)
        dispatchFetch({
          type: "filtering",
          filterText
        }, load);
    } catch (e) {
      dispatch({
        type: "error",
        error: e,
        abortController
      });
    }
  };
  let didDispatchInitialFetch = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    if (!didDispatchInitialFetch.current) {
      dispatchFetch({
        type: "loading"
      }, load);
      didDispatchInitialFetch.current = true;
    }
  }, []);
  return {
    items: data.items,
    selectedKeys: data.selectedKeys,
    sortDescriptor: data.sortDescriptor,
    isLoading: data.state === "loading" || data.state === "loadingMore" || data.state === "sorting" || data.state === "filtering",
    loadingState: data.state,
    error: data.error,
    filterText: data.filterText,
    getItem(key) {
      return data.items.find((item) => getKey(item) === key);
    },
    reload() {
      dispatchFetch({
        type: "loading"
      }, load);
    },
    loadMore() {
      if (data.state === "loadingMore" || data.state === "filtering" || data.cursor == null)
        return;
      dispatchFetch({
        type: "loadingMore"
      }, load);
    },
    sort(sortDescriptor) {
      dispatchFetch({
        type: "sorting",
        sortDescriptor
      }, sort || load);
    },
    ...(0, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a)({
      ...options,
      getKey,
      cursor: data.cursor
    }, (fn) => {
      dispatch({
        type: "update",
        updater: fn
      });
    }),
    setFilterText(filterText) {
      dispatchFetch({
        type: "filtering",
        filterText
      }, load);
    }
  };
}

// ../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/useTreeData.mjs
var import_react3 = __toESM(require_react(), 1);
function $be2ea0343af54212$export$d14e1352e21f4a16(options) {
  let { initialItems = [], initialSelectedKeys, getKey = (item) => item.id || item.key, getChildren = (item) => item.children } = options;
  let [tree, setItems] = (0, import_react3.useState)(() => buildTree(initialItems, /* @__PURE__ */ new Map()));
  let { items, nodeMap } = tree;
  let [selectedKeys, setSelectedKeys] = (0, import_react3.useState)(new Set(initialSelectedKeys || []));
  function buildTree(initialItems2 = [], map, parentKey) {
    return {
      items: initialItems2.map((item) => {
        let node = {
          key: getKey(item),
          parentKey,
          value: item,
          children: null
        };
        node.children = buildTree(getChildren(item), map, node.key).items;
        map.set(node.key, node);
        return node;
      }),
      nodeMap: map
    };
  }
  function updateTree(items2, key, update, originalMap) {
    let node = originalMap.get(key);
    if (!node)
      return {
        items: items2,
        nodeMap: originalMap
      };
    let map = new Map(originalMap);
    let newNode = update(node);
    if (newNode == null)
      deleteNode(node, map);
    else
      addNode(newNode, map);
    while (node.parentKey) {
      let nextParent = map.get(node.parentKey);
      let copy = {
        key: nextParent.key,
        parentKey: nextParent.parentKey,
        value: nextParent.value,
        children: null
      };
      let children = nextParent.children;
      if (newNode == null)
        children = children.filter((c) => c !== node);
      copy.children = children.map((child) => {
        if (child === node)
          return newNode;
        return child;
      });
      map.set(copy.key, copy);
      newNode = copy;
      node = nextParent;
    }
    if (newNode == null)
      items2 = items2.filter((c) => c !== node);
    return {
      items: items2.map((item) => {
        if (item === node)
          return newNode;
        return item;
      }),
      nodeMap: map
    };
  }
  function addNode(node, map) {
    map.set(node.key, node);
    for (let child of node.children)
      addNode(child, map);
  }
  function deleteNode(node, map) {
    map.delete(node.key);
    for (let child of node.children)
      deleteNode(child, map);
  }
  return {
    items,
    selectedKeys,
    setSelectedKeys,
    getItem(key) {
      return nodeMap.get(key);
    },
    insert(parentKey, index, ...values) {
      setItems(({ items: items2, nodeMap: originalMap }) => {
        let { items: newNodes, nodeMap: newMap } = buildTree(values, originalMap, parentKey);
        if (parentKey == null)
          return {
            items: [
              ...items2.slice(0, index),
              ...newNodes,
              ...items2.slice(index)
            ],
            nodeMap: newMap
          };
        return updateTree(items2, parentKey, (parentNode) => ({
          key: parentNode.key,
          parentKey: parentNode.parentKey,
          value: parentNode.value,
          children: [
            ...parentNode.children.slice(0, index),
            ...newNodes,
            ...parentNode.children.slice(index)
          ]
        }), newMap);
      });
    },
    insertBefore(key, ...values) {
      let node = nodeMap.get(key);
      if (!node)
        return;
      let parentNode = nodeMap.get(node.parentKey);
      let nodes = parentNode ? parentNode.children : items;
      let index = nodes.indexOf(node);
      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index, ...values);
    },
    insertAfter(key, ...values) {
      let node = nodeMap.get(key);
      if (!node)
        return;
      let parentNode = nodeMap.get(node.parentKey);
      let nodes = parentNode ? parentNode.children : items;
      let index = nodes.indexOf(node);
      this.insert(parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1, ...values);
    },
    prepend(parentKey, ...values) {
      this.insert(parentKey, 0, ...values);
    },
    append(parentKey, ...values) {
      if (parentKey == null)
        this.insert(null, items.length, ...values);
      else {
        let parentNode = nodeMap.get(parentKey);
        if (!parentNode)
          return;
        this.insert(parentKey, parentNode.children.length, ...values);
      }
    },
    remove(...keys) {
      if (keys.length === 0)
        return;
      let newItems = items;
      let prevMap = nodeMap;
      let newTree;
      for (let key of keys) {
        newTree = updateTree(newItems, key, () => null, prevMap);
        prevMap = newTree.nodeMap;
        newItems = newTree.items;
      }
      setItems(newTree);
      let selection = new Set(selectedKeys);
      for (let key of selectedKeys)
        if (!newTree.nodeMap.has(key))
          selection.delete(key);
      setSelectedKeys(selection);
    },
    removeSelectedItems() {
      this.remove(...selectedKeys);
    },
    move(key, toParentKey, index) {
      setItems(({ items: items2, nodeMap: originalMap }) => {
        let node = originalMap.get(key);
        if (!node)
          return {
            items: items2,
            nodeMap: originalMap
          };
        let { items: newItems, nodeMap: newMap } = updateTree(items2, key, () => null, originalMap);
        const movedNode = {
          ...node,
          parentKey: toParentKey
        };
        if (toParentKey == null) {
          newMap.set(movedNode.key, movedNode);
          return {
            items: [
              ...newItems.slice(0, index),
              movedNode,
              ...newItems.slice(index)
            ],
            nodeMap: newMap
          };
        }
        return updateTree(newItems, toParentKey, (parentNode) => ({
          key: parentNode.key,
          parentKey: parentNode.parentKey,
          value: parentNode.value,
          children: [
            ...parentNode.children.slice(0, index),
            movedNode,
            ...parentNode.children.slice(index)
          ]
        }), newMap);
      });
    },
    update(oldKey, newValue) {
      setItems(({ items: items2, nodeMap: originalMap }) => updateTree(items2, oldKey, (oldNode) => {
        let node = {
          key: oldNode.key,
          parentKey: oldNode.parentKey,
          value: newValue,
          children: null
        };
        let tree2 = buildTree(getChildren(newValue), originalMap, node.key);
        node.children = tree2.items;
        return node;
      }, originalMap));
    }
  };
}
export {
  $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList,
  $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData,
  $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData
};
//# sourceMappingURL=@react-stately_data.js.map
