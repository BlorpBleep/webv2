{
  "version": 3,
  "sources": ["../../../../../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useListData.ts", "../../../../../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useAsyncList.ts", "../../../../../../node_modules/.pnpm/@react-stately+data@3.11.4_react@18.3.1/node_modules/@react-stately/data/dist/packages/@react-stately/data/src/useTreeData.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, Selection} from '@react-types/shared';\nimport {useMemo, useState} from 'react';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          if (state.items.length === 0) {\n            index = 0;\n          } else {\n            return state;\n          }\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort((a, b) => a - b);\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  toIndex -= indices.filter(index => index < toIndex).length;\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, LoadingState, Selection, SortDescriptor} from '@react-types/shared';\nimport {Reducer, useEffect, useReducer, useRef} from 'react';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  let didDispatchInitialFetch = useRef(false);\n  useEffect(() => {\n    if (!didDispatchInitialFetch.current) {\n      dispatchFetch({type: 'loading'}, load);\n      didDispatchInitialFetch.current = true;\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from '@react-types/shared';\nimport {useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into. `null` for the root.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key | null, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n\n  // We only want to compute this on initial render.\n  let [tree, setItems] = useState<{items: TreeNode<T>[], nodeMap: Map<Key, TreeNode<T>>}>(() => buildTree(initialItems, new Map()));\n  let {items, nodeMap} = tree;\n\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], map: Map<Key, TreeNode<T>>, parentKey?: Key | null) {\n    return {\n      items: initialItems.map(item => {\n        let node: TreeNode<T> = {\n          key: getKey(item),\n          parentKey: parentKey,\n          value: item,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(item), map, node.key).items;\n        map.set(node.key, node);\n        return node;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>, originalMap: Map<Key, TreeNode<T>>) {\n    let node = originalMap.get(key);\n    if (!node) {\n      return {items, nodeMap: originalMap};\n    }\n    let map = new Map<Key, TreeNode<T>>(originalMap);\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node, map);\n    } else {\n      addNode(newNode, map);\n    }\n\n    // Walk up the tree and update each parent to refer to the new children.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return {\n      items: items.map(item => {\n        if (item === node) {\n          return newNode;\n        }\n\n        return item;\n      }),\n      nodeMap: map\n    };\n  }\n\n  function addNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child, map);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>, map: Map<Key, TreeNode<T>>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child, map);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return nodeMap.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let {items: newNodes, nodeMap: newMap} = buildTree(values, originalMap, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return {\n            items: [\n              ...items.slice(0, index),\n              ...newNodes,\n              ...items.slice(index)\n            ],\n            nodeMap: newMap\n          };\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...newNodes,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = nodeMap.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = nodeMap.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = nodeMap.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      if (keys.length === 0) {\n        return;\n      }\n\n      let newItems = items;\n      let prevMap = nodeMap;\n      let newTree;\n      for (let key of keys) {\n        newTree = updateTree(newItems, key, () => null, prevMap);\n        prevMap = newTree.nodeMap;\n        newItems = newTree.items;\n      }\n\n      setItems(newTree);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!newTree.nodeMap.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key | null, index: number) {\n      setItems(({items, nodeMap: originalMap}) => {\n        let node = originalMap.get(key);\n        if (!node) {\n          return {items, nodeMap: originalMap};\n        }\n\n        let {items: newItems, nodeMap: newMap} = updateTree(items, key, () => null, originalMap);\n\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        // If parentKey is null, insert into the root.\n        if (toParentKey == null) {\n          newMap.set(movedNode.key, movedNode);\n          return {items: [\n            ...newItems.slice(0, index),\n            movedNode,\n            ...newItems.slice(index)\n          ], nodeMap: newMap};\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(newItems, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }), newMap);\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(({items, nodeMap: originalMap}) => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        let tree = buildTree(getChildren(newValue), originalMap, node.key);\n        node.children = tree.items;\n        return node;\n      }, originalMap));\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["$bc4N1$useState", "$bc4N1$useMemo", "item", "key", "$fh1mr$useReducer", "$fh1mr$useRef", "$fh1mr$useEffect", "$3pPTd$useState", "initialItems", "items", "tree"]
}
